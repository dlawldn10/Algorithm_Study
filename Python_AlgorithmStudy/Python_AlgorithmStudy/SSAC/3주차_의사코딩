

#0816_2주차 의사코딩

이번주 메인 과제는 -> 구글 설문조사. 
 자료구조 문제들 풀이법 및 pseudo code(의사코드)제출.
 문제 해결 능력을 좀 더 키우기 위해서.
- 실 구현은 할 필요 없음
- 어떤 자료구조를 사용해서 어떻게 풀면 되는지.
- ex) 리스트는 이러이러해서 시간 때문에 안될것 같다. 
      대신에 이러한 이유때문에 이러한 것을 써야할 것 같다. 


# 1743 음식물 피하기
상하 좌우로 인접한 음식물의 개수를 파악하여 합한 것이 가장 큰것의 크기를 구해야 한다.
즉 연결 요소들 중 가장 큰 연결요소를구해야한다.
인접한 음식물을 파악하기 위해 인접행렬로 접근하였고,
최단거리를 묻는 문제가 아니어서 DFS BFS 모두 가능할 것이라 생각하였다.
그 중 DFS를 선택하였다.

한 행렬은 음식물이 있는 좌표엔 1을, 없는 좌표엔 0을 저장한다.
한 행렬은 빙문 체크를 할 행렬로 음식물이 있는 좌표엔 true값을, 없는 좌표엔 fasle값을 저장한다.

행렬을 상,하,좌,우의 방향으로 각각 검사해가면서 
1을 만나면 크기를 저장하는 변수K에 하나씩 더하고, 0이면 그냥 지나가는 재귀함수를 통해 DFS를 한바퀴 돌린다(=인접한 노드가 없을때까지 반복한다). 
방문한적 없는 노드(=fasle인 노드)는 true로 갱신하고, 방문한 적 있는 노드(=true)는 다음으로 넘어가며 방문체크를 함께한다.

그 후 본래 있던 K값과 이번에 구한 K값을 비교해서 더 큰 값이라면 갱신하고, 작은값이면 다음 DFS를 시행한다.
이를 모든 노드의 방문체크가 true가 될때까지 반복한다.



# 2667 단지번호붙이기
상하 좌우로 인접한 집의 개수를 파악하고, 단지의 갯수도 구하는 문제이다.
즉,연결 요소를 모두 구하고 각각의 연결요소의 구성요소들의 갯수를 구해야한다.
인접 행렬을 이용하여 접근하였고, DFS BFS 모두 가능할 것이라 생각하였다.
그 중 DFS를 사용하였다. 

각 단지의 집의 수를 셀 변수 cnt와
각 단지의 집의 수 cnt 를 저장할 리스트 house를 선언한다.

한 행렬에 0과 1값들을 저장하고.
한 행렬은 방문체크를 하기 위해 fasle값을 넣어 초기화 한다.

행렬을 상,하,좌,우의 방향으로 각각 검사해가면서 
1을 만나면 크기를 저장하는 변수cnt에 하나씩 더하고, 0이면 그냥 지나가는 재귀함수를 통해 DFS를 한바퀴 돌린다. 
방문한적 없는 노드(=fasle인 노드)는 true로 갱신하고, 방문한 적 있는 노드(=true)는 다음으로 넘어가며 방문체크를 함께한다.

더이상 인접한 노드가 없을때는 cnt를 house 리스트에 append하고 cnt를 0으로 초기화한다.

그리고 이를 모든 노드의 방문체크가 true가 될때까지 반복한다.



# 2583 영역 구하기
각 영역의 넓이를 저장할 리스트 W를 하나 생성한다.

(5, 7) 크기의 0으로 초기화된 행렬 하나를 생성한다.
왼쪽 아래 좌표의 x좌표가 오른쪽 위의 x표와 같은때까지 더해가며 1 값을 넣는다.
그 후엔 y를 하나 더하고 위 과정을 반복한다.

이 두 과정을 왼쪽 아래 좌표의 y좌표가 오른쪽 위 좌표의 y좌표와 같아질때까지 반복한다.

이것을 모든 직사각형에 대하여 반복하는데,
이 과정을 수행하는도중 이미 1값이 넣어져 있는 경우 무시하고 다음으로 넘어간다.

행렬에 1 대입을 완전히 마친 후,
DFS를 사용하여 인접한 0들의 갯수를 cnt변수를 이용하여 센 후, 
cnt값을 W에 append한다.

모든 노드에 대하여 DFS과정이 끝나면
리스트 W를 오름차순 정리하여 프린트한다.



# 10026 적록색약
먼저 B의 구역을 구한다. 
그러면 적록 색약인 사람의 R-G와 B구역을 알 수 있다. -> 적록 색약인 사람이 봤을 때의 구역의 수.
그 다음 R의 영역을 구한다. -> 색약이 아닌 사람이 봤을 때의 구역의 수.

RGB들의 입력을 받아 행렬을 초기화한다.
방문 체크를 할 행렬에 노드를 모두 0으로 초기화한다.
각 구역의 수를 저장할 리스트 K를 선언한다.

DFS를 사용해서 먼저 B인 구역을 구한다.
상하좌우 확인을 통해 더이상 인접한 B가 없을때 까지 방문체크를 하면서 검사하고 cnt변수에 +1 한다.
이를 모든 노드를 대상으로 진행한 후 cnt를 K에 append한다.
이후 cnt를 0으로 다시 초기화해주고

방문체크가 false인 인접한 노드들을 방문체크를 해주며 검사하여 cnt값을 K에 append한다.

여기까지 과정으로 통해 색약인 사람이 봤을 때 구역의 수를 구하고,

이후 행렬을 처음부터 보며 B가 아닌 노드들은 방문체크를 다시 false로 돌려준다.

이제 R과 G를 구분하여 방문체크하고 연결요소들의 갯수를 구한 뒤 K에 각각 append해준다.

이를 통해 색약이 아닌 사람이 봤을 때 구역의 수를 구할 수 있다.




# 2468 안전 영역
행렬을 입력받아 초기화한다. 이때 입력받는 수들 중에서 가장 큰수 M을 찾아낸다.
방문체크용 행렬도 함께 초기화한다.

높이 체크를 할 변수 m을 선언한다. m은 최대 M까지 증가한다.

연결요소들의 총 갯수를 기록할 리스트 L을 선언한다.

총 갯수를 누적하여 더해줄 변수 K를 생성한다. 

행렬을 모두 돌며 m보다 큰 값을 가진 노드들의 갯수를 cnt변수로 세어, 
인접하고 M보다 큰 값을 가진 노드가 없을 때까지 검사한다.
그 후 연결 요소들을 누적하여 K에 더한다.
m일때가 모두 끝나면 K를 L에 append하고,
K를 초기화 후 m+1일때로 위의 과정을 반복한다.

이를 m이 M이 될때까지 반복하고, 
리스트 L에서 max값을 구한다.



# 6593 상범 빌딩
이전 문제들과 달리 방향이 추가되었다.
dx, dy, dz까지 생성한다.
z까지 고려하여 3차원 행렬을 생성한다.
*3차원 행렬을 생성하는 방법
dp = [[[0]*(한 층의 열) for i in range(한 층의 행))] for i in range(총 층의 수)]
방문체크용 행렬도 생성한다.

입력을 받아 dp에 저장하면서 S와 E가 있다면 따로 찾아 s, e의 좌표를 기록한다.

오른쪽, 왼쪽, 위, 아래, 앞, 뒤를 모두 검사해서 갈 수 있는 곳이라면 min 에 +1 을 하여 걸리는 시간을 기록한다.
최단 시간을 구해야하므로 bfs를 사용 해야 한다.
E의 좌표로 이동할때까지 반복하고, E로 도착하지 못했는데 탐색이 끝났다면 Trapped를 출력한다.
E에 도착했다면 걸린 시간을 출력한다.



# 5427 불
얼마나 빨리 빌딩을 탈출할 수 있는지 구하는 것이므로 bfs를 사용한다.
동서남북으로 이동할 수 있으므로 dx, dy를 설정한다.

입력받은 대로 행렬을 생성하고, 상근이@의 위치를 파악한다.
상근이의 위치에서부터 bfs 탐색을 시작한다.

상근이는 .인 곳과 *(불)의 다음 목적지가 아닌 곳으로만 이동할 수 있다.

먼저 상근이를 이동시키고 그 다음 불을 이동하도록 한다.

앞뒤좌우를 검사하여 .이라면 한칸이동한다(큐에 append).
그 후 전체를 다시 검사하며 *을 만났을 경우, 그곳의 앞뒤좌우를 검사하여 .이라면 그것을 *로 바꾼다.

위 과정을 상근이가 더이상 이동할 수 없거나 건물 밖으로 나갈때까지 반복한다.
 


# 3055 탈출
*다른 사람 풀이 참고한 해답
fs로 고슴도치를 먼저 움직여 준다음 물을 움직여 준다.
물은 돌이 아니거나 D가 아니라면 다 덮어준다.
bfs를 다 수행했을때 D의 위치에 고슴도치가 도착했다면 시간을 출력해준다.



# 2206 벽 부수고 이동하기
벽을 한번 부술 수 있으므로 이동할 좌표와, 벽을 부순 횟수를 기록할 변수까지 하여3중 배열을 선언한다.
최단 경로를 구하는 프로그램이므로 bfs사용한다.

앞뒤좌우를 검사해서 벽이 있는데 아직 뚫기 전이라면 벽을 뚫고 전진한다.
벽이 있는데 이미 뚫고 난 후라면 다른 길을 찾는다.



# 7576 토마토
토마토가 모두 익을때까지의 최소 날짜를 출력해야 하므로 bfs를 사용한다.
익은 토마토들의 좌표를 넣을 큐를 생성한다.

1인 곳 부터 시작해서 앞뒤좌우가 0이라면 익은 토마토를 넣는 큐에 push한다.
그리고 날짜에 +1하여 갱신한다.

탐색이 모두 끝난 후 0이 하나라도 있다면 -1을 출력하고
다 익었다면 날짜를 출력한다.



# 7562 나이트의 이동
나이트는 앞뒤좌우로 두칸, 그 후 오른쪽이나 왼쪽으로 한칸 이동할 수 있다.
즉, 이와같이 표현할 수 있다.
dx = [-1, -2, -2, -1, 1, 2, 2, 1]
dy = [2, 1, -1, -2, -2, -1, 1, 2]

나이트가 최소 몇번만에 목표지로 이동할 수 있는지 출력해야하므로 bfs를 이용한다.



# 5014 스타트링크
방향을 이와같이 적용하고
dy = [u, -u]
버튼을 적어도 몇번 눌러야하는지 구해야하므로 bfs를 이용한다.


# 1697 숨바꼭질
*다른 사람 풀이 참고한 해답
수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇초인지 수하는 프로그램이므로 bfs를 사용한다.

bfs를 이용해 풀었다. 처음 시작점 N에서 갈 수 있는 점 N*2, N+1, N-1 세 점에서 또 각점이 갈 수 있는 세 점씩을 계속 탐색해서 K와 같을 때를 찾으면 된다. 
단, count를 +1 해주는 위치와 사용하는 방법이 중요한데, count를 방문 안했을시 방문 할 때마다 +1 해주면 다른 탐색도 거쳐와서 N == K 일때도 생길 수 있기 때문에 count 값이 크게 나온다. 
때문에 e라는 점이 큐에 몇번째로 들어갔는지 판단후 +1 해주기 위해 count를 q에 같이 넣어줌으로써 해결했다.




# 16397 탈출
버튼을 누르는 횟수를 최소로하여 방을 탈출해야하므로 bfs를 이용한다.
나머지는 여타 bfs풀이와 같을 것이다.



# 9019 DSLR
A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램이므로 bfs를 사용한다.
D, S, L, R 명령을 하나씩 수행해주면서 해당 값을 찾는다.



# 1525 퍼즐
최소 이동 횟수를 구하는 프로그램이므로 bfs사용한다.
어떤 수와 인접해 있는 네 개의 칸 중에 하나가 비어 있으면, 수를 그 칸으로 이동시킬 수있다.

*다른 사람 풀이 참고한 해답
딕셔너리의 키를 3x3행렬의 모든 좌표를 일렬로 나열한 것을 key로 하고, 
거기까지 움직인 수를 value로 갖도록 했다.

예를 들어서 다음과 같이 key를 정했다.
1 0 3
4 2 5
7 8 6
→ key : "103425786"

 
이런 식으로 딕셔너리를 통해 방문 여부를 점검하면 3x3크기의 배열의 형태를 메모리 제한 오류가 발생하지 않고도 다룰 수 있게 됐다.

상하좌우로 이동할 수 있고 아직 점검하지 않은 형태의 모습 (딕셔너리의 키)라면 큐에 넣도록 했다.



# 1039 교환
*다른 사람 풀이 참고한 해답
1. 입력의 자릿수에 대해 2개씩 조합할 수 있는 경우를 구해놓는다
2. 자릿수를 K번째 까지 계속 바꾼 후 만들 수 있는 가장 큰 수를 출력한다
만약 ans 값이 초기값인 0 그대로면 만들 수 없다는 뜻이므로 -1 출력



# 1182 부분수열의 합
*다른 사람 풀이 참고한 해답
재귀함수로 구현을 해준다.
dfs(idx, sum)을 했을때, sum에 해당 인덱스를 포함하는 dfs와 포함하지 않는 dfs를 실행시킨다.

import sys
input = sys.stdin.readline
def dfs(idx, sum):
    global cnt
    if idx >= n:
        return
    sum += s_[idx]
    if sum == s:
        cnt += 1
    dfs(idx + 1, sum - s_[idx])
    dfs(idx + 1, sum)
n, s = map(int, input().split())
s_ = list(map(int, input().split()))
cnt = 0
dfs(0, 0)
print(cnt)



# 9663 N-Queen
*다른 사람 풀이 참고한 해답
퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력하는 문제이다.
퀸은 상하좌우 대각선까지 모두 공격이 가능하기 때문에 상하좌우 대각선을 제외하고 놔야한다.

행과열을 저장해야 하기때문에 이중리스트를 사용하려 했는데 리스트 한개만으로 행과열을 표현할 수 있다.

row라는 리스트가 있다고 할때 row에 index값들을 행으로 보고 row[index]의 값을 열로 나타내면 된다.

adjacent 함수를 보면 상하좌우 대각선에 놓을 것인지 확인해주는 함수이다.

같은 행인지 확인 : for문을 돌릴때 x전까지 돌리기 때문에 i와 x가 같을 일은 없기때문에 같은 행에 놓을 수는 없기 때문에 조건문에 안넣어도 된다.
같은 열인지 확인 : 열을 확인해주기 위해서 row[x]와 row[i]를 비교해줘서 같은경우 놓을 수 없기 때문에 false를 준다.
같은 대각선상 인지 확인 : 대각선을 확인하는데 같은 대각선상에 있다는 뜻은 행끼리 뺀 값과 열끼리 뺸 값이 같으면 대각선상에 있다는 뜻이다.
유망한곳인지 확인을 해주는 함수 adjacent함수를 이용해 true이면 유망한곳이기 때문에 계속 dfs를 진행하고 false일 경우 빠르게 빠져나오는 것을 백트래킹 이라고 한다.

 

# 2580 스도쿠
*다른 사람 풀이 참고한 해답
스도쿠는 DFS(깊이 우선 탐색)과 백트래킹(브루트 포스, 전부 탐색)으로 풀 수 있다.

다만 너무 많은 재귀, 검사를 할 것에 대비해 유망한 숫자 검사(is_promising)와 재귀를 최소화 해줄 수 있게(zeros 리스트) 만든다.

1) 0인 부분만을 찾는다.
2) 유망한 숫자(해당 칸 안에 들어갈 수 있는 숫자)를 알려줄 is_promising 함수를 만든다

2-1) 행, 열, 3*3박스 안에서 검사할 수 있게 만든다.
3) 유망한 숫자들을 집어넣는다.
4) 다음 0인 부분으로 넘어간다. ( 재귀함수를 호출한다. )
5) 해당 부분을 다시 0으로 초기화 시켜 놓는다. ( 4)의 재귀 함수 내부에서 정답이 없을 경우를 고려 )
6) 마지막 0까지 모두 넣어봤다면, 출력한다.




# 17136 색종이 붙이기
*다른 사람 풀이 참고한 해답
1. a에 종이의 상태를 저장하고 paper에 다섯 종류의 색종이를 각각 몇 장 사용했는지 저장한다

2. (0, 0)부터 시작해서 a[x][y]가 1인 모든 좌표에서 크기 1~5인 색종이를 붙여가면서 모든 케이스를 확인해야 한다

3. x좌표가 범위를 넘어가면 (0, y+1)로 재귀한다

   y가 범위를 넘어가면 맨 끝까지 탐색한 것이므로 최소값을 갱신한다

4. a[x][y]가 0이면 (x+1, y)로 재귀한다

   1이면 크기 1부터 5까지 색종이를 붙일 수 있는지 확인한다

5. 만약 색종이 5장을 이미 붙였거나 범위를 벗어나는 크기의 색종이라면 continue한다

6. 색종이를 붙일 수 있는지 확인한다. 단순히 반복문으로 0이 있는지 검사하면 된다

7. 붙일 수 있으면 다시 반복문으로 색종이를 붙이는 칸의 숫자를 0으로 바꿔준다

8. paper를 증가시켜 주고 (x+k+1, y)로 재귀한다

   그다음에는 paper와 지운 칸을 다시 되돌려준다